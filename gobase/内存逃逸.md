### 内存分配
Go语言的堆栈分配是通过 Compiler 进行分析，GC 去管理的
* 堆（Heap）：一般来讲是人为手动进行管理，手动申请、分配、释放。
    一般所涉及的内存大小并不定，一般会存放较大的对象。另外其分配相对慢，涉及到的指令动作也相对多。
* 栈（Stack）：由编译器进行管理，自动申请、分配、释放。
     一般不会太大，我们常见的函数参数（不同平台允许存放的数量不同），局部变量等等都会存放在栈上。

#### 性能分析方式    
##### 性能分析类型
* CPU 性能分析，runtime 每隔 10 ms 中断一次，记录此时正在运行的 goroutines 的堆栈信息
* 内存性能分析，记录堆内存分配时的堆栈信息，忽略栈内存分配信息，默认每 1000 次采样 1 次
* 阻塞性能分析，GO 中独有的，记录一个协程等待一个共享资源花费的时间
* 锁性能分析，记录因为锁竞争导致的等待或延时

##### CPU 性能分析
使用原生 runtime/pprof 包，通过在 main 函数中添加代码运行可生成性能分析报告：
pprof.StartCPUProfile(os.Stdout)
defer pprof.StopCPUProfile()
可通过 go tool pprof -http=:9999 cpu.pprof 在 web 页面查看分析数据
可通过 go tool pprof cpu.prof 交互模式查看分析数据，可使用 help 查看支持的命令和选项

##### 内存性能分析
使用 pkg/profile 库，通过在 main 函数中添加代码运行可生成性能分析报告：
defer profile.Start(profile.MemProfile, profile.MemProfileRate(1)).Stop()
同样可通过 web 页面或交互模式查看分析数据

##### benchmark 生成 profile
可通过在 go test  中添加参数 -cpuprofile=$FILE,-memprofile=$FILE,-blockprofile=$FILE 生成相应的 profile 文件
生成的 profile 文件同样可通过 web 页面或交互模式查看分析数据
     

### 逃逸分析
#### 什么是逃逸分析
Go 语言中，堆内存是通过垃圾回收机制自动管理的，无需开发者指定。那么，Go 编译器怎么知道某个变量需要分配在栈上，还是堆上呢？
编译器决定内存分配位置的方式，就称之为逃逸分析(escape analysis)。逃逸分析由编译器完成，作用于编译阶段。它通过分析用户源码，
决定哪些变量应该在堆栈中分配，哪些变量应该逃逸到堆中。规则如下：
* 是否有在其他地方（非局部）被引用，只要有可能被引用了，那么他一定被分配到堆上。
* 即使没有被外部引用，单对象过大，无法存放到栈区上，他有可能被分配到堆上。

#### 原理
在新版逃逸分析实现的注释中（$GOROOT/src/cmd/compile/internal/gc/escape.go），我们可以大致了解逃逸分析的实现原理。注释中的原理说明中提到了算法基于的两个不变性：
1. 指向栈的指针不能存储在堆中；
2. 指向栈对象的指针不能超过该栈对象的存活期（即：指针不能在栈对象被销毁后依旧存活）

#### 为什么需要逃逸
简单来说，就是为了"按需分配"，最大限度灵活利用资源。
这个问题可以反过来想，如果变量都分配到堆上会有什么问题？
* 垃圾回收的压力不断增大
* 申请、分配、回收内存的系统开销变大
* 动态分配产生一定量的内存碎片
简单来说，频繁申请并分配堆内存是有一定代价的。会影响应用程序运行的效率，间接影响到整体系统。

#### 如何确定逃逸分析
1. go build -gcflags '-m -l' main.go
-gcflags 用于将标识参数传递给 Go 编译器；
-m：打印出逃逸分析的优化策略。
-l: 禁用函数内联，在这里禁用掉 inline 能更好地观察逃逸情况，减少干扰。

2. 通过反编译命令查看： go tool compile -S main.go


#### 逃逸场景

1. 指针逃逸
在函数中创建了一个对象，在返回值中 返回了这个对象的指针。这种情况下，函数虽然退出了，但是因为指针的存在，对象的内存不能随着函数结束而回收，因此只能分配在堆上。

2. interface{} 动态类型逃逸
在 Go 语言中，空接口即 interface{} 可以表示任意的类型，如果函数参数为 interface{}，编译期间很难确定其参数的具体类型，也会发生逃逸。
```
func main() {
	demo := createDemo("demo")
	fmt.Println(demo)
}
```
demo 是 main 函数中的一个局部变量，该变量作为实参传递给 fmt.Println()，但是因为 fmt.Println() 的参数类型定义为 interface{}，因此也发生了逃逸。

3. 栈空间不足 （大对象）
操作系统对内核线程使用的栈空间是有大小限制的，64 位系统上通常是 8 MB。可以使用 ulimit -a 命令查看机器上栈允许占用的内存的大小。
对于 Go 语言来说，运行时(runtime) 尝试在 goroutine 需要的时候动态地分配栈空间，goroutine 的初始栈大小为 2 KB。
当 goroutine 被调度时，会绑定内核线程执行，栈空间大小也不会超过操作系统的限制。

```
admin@niuwenyandeMac uauth % ulimit -a
-s: stack size (kbytes)             8192
-c: core file size (blocks)         0
-u: processes                       2784
-n: file descriptors                256
...
```

4. 闭包
> 一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。
>也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。
>  — 闭包


#### 如果利用逃逸分析提高性能
* 传值 vs 传指针
传值会拷贝整个对象，而传值】指针只会拷贝指针地址，指向的对象是同一个。传指针可以减少值的拷贝，但是会导致内存分配逃逸到堆中，增加垃圾回收的负担。
在对象频繁创建和删除的场景下，传递指针导致的 GC 开销可能会严重影响性能。
一般情况下，对于需要修改原对象的值，或占用内存较大的结构体，选择传指针。对于只读的占用内存较小的结构体，直接传值有更好的性能。


#### 总结：
1. 静态分配到栈上，性能一定比动态分配到堆上好。
2. 底层分配到堆，还是栈。实际上对你来说是透明的，不需要过度关心。
3. 到处都用指针传递并不一定是最好的，要用对。
4. 每个 Go 版本的逃逸分析都会有所不同（会改变，会优化）。
5. 直接通过go build -gcflags '-m -l'就可以看到逃逸分析的过程和结果。