### 垃圾回收

优质资源
https://developer.aliyun.com/article/775798
#### GC目标
* 当程序终止时，尽可能减少在这2个阶段的STW - Stop The World 暂停所有任务的执行（次数）
* 一个 GC 周期的时间要少于 10 ms
* 一次 GC 周期不要占用超 25% 的 CPU 资源

#### 触发时机
1. 到达堆阈值：GC 将会关注的第一个指标是堆的使用增长，在堆大小加倍时触发 GC
2. 到达时间阈值：GC 关注的第二个指标是在两次 GC 之间的时间间隔。如果超过两分钟 GC 还未执行，那么就会强制启动一次 GC 循环。

追踪法：三色标记法；分代法；
引用计数法：循环引用问题；性能问题；


#### 三色标记法（标记-清除法）
三色标记法属于增量式GC算法，回收器首先将所有的对象着色成白色，然后从GC Root出发，逐步把所有“可达”的对象变成灰色再到黑色，最终所有的白色对象即是“不可达”对象。
具体的实现如下：

* 初始时所有对象都是白色对象
* 从GC Root对象出发，扫描所有可达对象并标记为灰色，放入待处理队列
* 从队列取出一个灰色对象并标记为黑色，将其引用对象标记为灰色放入队列
* 重复上一步骤，直到灰色对象队列为空
* 此时所有剩下的白色对象就是垃圾对象
优点：
不需要暂停整个程序进行垃圾回收
缺点：
如果程序垃圾对象的产生速度大于垃圾对象的回收速度时，可能导致程序中的垃圾对象越来越多而无法及时收集
线程切换和上下文转换的消耗会使得垃圾回收的总体成本上升，从而降低系统吞吐量

#### 屏障技术
强三色不变式：不允许黑色对象指向白色对象
弱三色不变式：允许黑色对象指向白色对象，但必须保证一个前提，这个白色对象必须处于灰色对象的保护下

内存屏障其实就是编译器帮你生成的一段 hook 代码，这三个屏障的本质区别就是 hook 的时机不同而已。

* 插入屏障
Dijkstra写屏障：插入屏障拦截将白色指针插入黑色对象的操作，标记其对应对象为灰色状态，这样就不存在黑色对象引用白色对象的情况了，满足强三色不变式，

```
writePointer(slot, ptr):
    shade(ptr)
    *slot = ptr
```
在Golang中，对栈上指针的写入添加写屏障的成本很高，所以Go选择仅对堆上的指针插入增加写屏障，这样就会出现在扫描结束后，栈上仍存在引用白色对象的情况，这时的栈是灰色的，不满足三色不变式，所以需要对栈进行重新扫描使其变黑，完成剩余对象的标记，这个过程需要STW。这期间会将所有goroutine挂起，当有大量应用程序时，时间可能会达到10～100ms。

* 删除屏障：删除指针指向时触发
删除屏障也是拦截写操作的，但是是通过保护灰色对象到白色对象的路径不会断来实现的。
也叫做基于其实快照的解决方案（snapshot-at-the-begining）。顾名思义，就是在开始 gc 之前，必须 STW ，对整个根做一次起始快照。当赋值器（业务线程）从灰色或者白色对象中删除白色指针时候，写屏障会捕捉这一行为，将这一行为通知给回收器。这样，基于起始快照的解决方案保守地将其目标对象当作存活的对象，这样就绝对不会有被误回收的对象，但是有扫描工作量浮动放大的风险。术语叫做追踪波面的回退。
```
writePointer(slot, ptr):
    if (isGery(slot) || isWhite(slot))
        shade(*slot)
    *slot = ptr
```

* 混合写屏障
插入屏障和删除屏障各有优缺点， Go1.8版本引入的混合写屏障结合了Yuasa的删除写屏障和Dijkstra的插入写屏障，结合了两者的优点
```
writePointer(slot, ptr):
    shade(*slot)
    if current stack is grey:
        shade(ptr)
    *slot = ptr
```
Golang中的混合写屏障满足的是变形的弱三色不变式
#### 