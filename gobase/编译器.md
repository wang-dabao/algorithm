### 认识 go build
go build 命令就是用来编译这其中的 命令源码文件 以及它依赖的 库源码文件。下面表格是一些常用的选项在这里集中说明以下。

可选项	说明
-a	    将命令源码文件与库源码文件全部重新构建，即使是最新的
-n	    把编译期间涉及的命令全部打印出来，但不会真的执行，非常方便我们学习
-race	开启竞态条件的检测，支持的平台有限制
-x	    打印编译期间用到的命名，它与 -n 的区别是，它不仅打印还会执行

通过 go build -n, 可以看到这一部分是编译的核心，通过 compile、 buildid、 link 三个命令会编译出可执行文件 a.out。
然后通过 mv 命令把 a.out 移动到当前文件夹下面，并改成跟项目文件一样的名字（这里也可以自己指定名字）。

### 编译器原理
![编译器流程](https://xiaomi-info.github.io/2019/11/13/golang-compiler-principle/go-byq-3.png)
#### 词法分析
* 词法分析简单来说就是将我们写的源代码翻译成 Token。
首先先来给 Go 的 token 类型分个类：变量名、字面量、操作符、分隔符以及关键字。
我们需要把一堆源代码按照规则进行拆分，其实就是分词，看着上面的例子代码我们可以大概制定一个规则如下：                             
    * 识别空格，如果是空格可以分一个词；
    * 遇到 ( 、)、’<’、’>’ 等这些特殊运算符的时候算一个分词；
    * 遇到 “ 或者 数字字面量算分词。
通过上面的简单分析，其实可以看出源代码转 Token 其实没有非常复杂，完全可以自己写代码实现出来。当然也有很多通过正则的方式实现的比较通用的词法分析器，像 Golang 早期就用的是 lex，在后面的版本中才改用了用 go 来自己实现。


#### 语法分析
所谓的语法分析就是将 Token 转化为可识别的程序语法结构，而 AST 就是这个语法的抽象表示。构造这颗树有两种方法。
    自上而下：这种方式会首先构造根节点，然后就开始扫描 Token，遇到 STRING 或者其它类型就知道这是在进行类型申明，func 就表示是函数申明。就这样一直扫描直到程序结束。
    `自下而上`：这种是与上一种方式相反的，它先构造子树，然后再组装成一颗完整的树。
go 语言进行语法分析使用的是自下而上的方式来构造 AST。

#### 语义分析（类型检查）
 go 的这个阶段叫 类型检查；那么语义分析（类型检查）究竟要做些什么呢？
 首先就是 Golang 文档中提到的会进行类型检查，还有类型推断，查看类型是否匹配，是否进行隐式转化（go 没有隐式转化）
 经过语义分析之后，就可以说明我们的代码结构、语法都是没有问题的。所以编译器前端主要就是解析出编译器后端可以处理的正确的 AST 结构。
 
 
#### 中间码生成（二进制码）
既然已经拿到 AST，机器运行需要的又是二进制。

#### 代码优化
在 go 的编译文档中，我并没找到独立的一步进行代码的优化。不过根据我们上面的分析，可以看到其实代码优化过程遍布编译器的每一个阶段。
通常我们除了用高效代码替换低效的之外，还有如下的一些处理：
> 并行性，充分利用现在多核计算机的特性
> 流水线，cpu 有时候在处理 a 指令的时候，还能同时处理 b 指令
> 指令的选择，为了让 cpu 完成某些操作，需要使用指令，但是不同的指令效率有非常大的差别，这里会进行指令优化
> 利用寄存器与高速缓存，我们都知道 cpu 从寄存器取是最快的，从高速缓存取次之。这里会进行充分的利用

#### 机器码生成(Plan9)
优化后的中间代码，首先会在这个阶段被转化为汇编代码（Plan9），而汇编语言仅仅是机器码的文本表示，机器还不能真的去执行它。
所以这个阶段会调用汇编器，汇编器会根据我们在执行编译时设置的架构，调用对应代码来生成目标机器码。

这里比有意思的是，Golang 总说自己的汇编器是跨平台的。其实他也是写了多分代码来翻译最终的机器码。因为在入口的时候他会根据我们所设置的 GOARCH=xxx 参数来进行初始化处理，
然后最终调用对应架构编写的特定方法来生成机器码。这种上层逻辑一致，底层逻辑不一致的处理方式非常通用，非常值得我们学习。