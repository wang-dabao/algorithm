### 分布式和集群的区别
* 分布式：1个业务分布成多个子系统，部署在不同的服务器上
* 集群：同一个业务，部署在多个服务器上，做的是同样的事

### 分布式和微服务的区别
* 微服务是分布式的一种实现方式
* 微服务关注的是分布式中的服务环节，分布式关注整个系统闭环

### 微服务通信的方式
方式：消息队列，RPC, HTTP, Web Service

RPC: Remote Procedure Call, 即远程过程调用。借助RPC可以做到像本地调用一样调用远程服务，是一种进程间的通信方式

#### 1. 核心组价
一个完整的RPC架构里面包含了四个核心的组件，分别是 Client，Client Stub，Server以及Server Stub ，这个Stub可以理解为存根。
* 客户端(Client)，服务的调用方。
* 客户端存根(Client Stub)，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。
* 服务端(Server)，真正的服务提供者。
* 服务端存根(Server Stub)，接收客户端发送过来的消息，将消息解包，并调用本地的方法
* 网络传输组件：

#### 核心模块
花了一个星期，我终于把RPC框架整明白了！
RPC(Remote Procedure Call)：远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的思想。

作者：李金葵来源：51CTO技术栈|2019-06-17 08:21 收藏  分享
【51CTO.com原创稿件】RPC(Remote Procedure Call)：远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的思想。

RPC 是一种技术思想而非一种规范或协议，常见 RPC 技术和框架有：

应用级的服务框架：阿里的 Dubbo/Dubbox、Google gRPC、Spring Boot/Spring Cloud。
远程通信协议：RMI、Socket、SOAP(HTTP XML)、REST(HTTP JSON)。
通信框架：MINA 和 Netty。
目前流行的开源 RPC 框架还是比较多的，有阿里巴巴的 Dubbo、Facebook 的 Thrift、Google 的 gRPC、Twitter 的 Finagle 等。

下面重点介绍三种：

gRPC：是 Google 公布的开源软件，基于***的 HTTP 2.0 协议，并支持常见的众多编程语言。RPC 框架是基于 HTTP 协议实现的，底层使用到了 Netty 框架的支持。
Thrift：是 Facebook 的开源 RPC 框架，主要是一个跨语言的服务开发框架。
用户只要在其之上进行二次开发就行，应用对于底层的 RPC 通讯等都是透明的。不过这个对于用户来说需要学习特定领域语言这个特性，还是有一定成本的。

Dubbo：是阿里集团开源的一个极为出名的 RPC 框架，在很多互联网公司和企业应用中广泛使用。协议和序列化框架都可以插拔是极其鲜明的特色。
完整的 RPC 框架

在一个典型 RPC 的使用场景中，包含了服务发现、负载、容错、网络传输、序列化等组件，其中“RPC 协议”就指明了程序如何进行网络传输和序列化。



图 1：完整 RPC 架构图

如下是 Dubbo 的设计架构图，分层清晰，功能复杂：



图 2：Dubbo 架构图



RPC 核心功能

RPC 的核心功能是指实现一个 RPC 最重要的功能模块，就是上图中的”RPC 协议”部分：



图 3：RPC 核心功能

一个 RPC 的核心功能主要有 5 个部分组成，分别是：客户端、客户端 Stub、网络传输模块、服务端 Stub、服务端等。



图 4：RPC 核心功能图

下面分别介绍核心 RPC 框架的重要组成：

客户端(Client)：服务调用方。
客户端存根(Client Stub)：存放服务端地址信息，将客户端的请求参数数据信息打包成网络消息，再通过网络传输发送给服务端。
服务端存根(Server Stub)：接收客户端发送过来的请求消息并进行解包，然后再调用本地服务进行处理。
服务端(Server)：服务的真正提供者。
Network Service：底层传输，可以是 TCP 或 HTTP。
Python 自带 RPC Demo

Server.py：

from SimpleXMLRPCServer import SimpleXMLRPCServer    
def fun_add(a,b): 
    totle = a + b  
    return totle 
if __name__ == '__main__': 
    s = SimpleXMLRPCServer(('0.0.0.0', 8080))   #开启xmlrpcserver 
    s.register_function(fun_add)                #注册函数fun_add 
    print "server is online..." 
    s.serve_forever()                           #开启循环等待 
Client.py：

from xmlrpclib import ServerProxy            #导入xmlrpclib的包 
s = ServerProxy("http://172.171.5.205:8080") #定义xmlrpc客户端 
print s.fun_add(2,3)         
开启服务端：



开启客户端：



Wireshark 抓包分析过程

客户端去往服务端：

客户端 IP：172.171.4.176
服务端 IP：172.171.5.95
通信使用 HTTP 协议，XML 文件传输格式。传输的字段包括：方法名 methodName，两个参数 2，3。



图 5：Request 抓包

服务端返回结果，字段返回值 Value，结果是 5：



图 6：Response 抓包

在这两次网络传输中使用了 HTTP 协议，建立 HTTP 协议之间有 TCP 三次握手，断开 HTTP 协议时有 TCP 四次挥手。



图 7：基于 HTTP 协议的 RPC 连接过程

详细调用过程

Python 自带 RPC 的 Demo 小程序的实现过程，流程和分工角色可以用下图来表示：



图 8：RPC 调用详细流程图

一次 RPC 调用流程如下：

服务消费者(Client 客户端)通过本地调用的方式调用服务。
客户端存根(Client Stub)接收到调用请求后负责将方法、入参等信息序列化(组装)成能够进行网络传输的消息体。
客户端存根(Client Stub)找到远程的服务地址，并且将消息通过网络发送给服务端。
服务端存根(Server Stub)收到消息后进行解码(反序列化操作)。
服务端存根(Server Stub)根据解码结果调用本地的服务进行相关处理
服务端(Server)本地服务业务处理。
处理结果返回给服务端存根(Server Stub)。
服务端存根(Server Stub)序列化结果。
服务端存根(Server Stub)将结果通过网络发送至消费方。
客户端存根(Client Stub)接收到消息，并进行解码(反序列化)。
服务消费方得到最终结果。


#### RPC 核心之功能实现
RPC 的核心功能主要由 5 个模块组成，如果想要自己实现一个 RPC，最简单的方式要实现三个技术点，分别是：
* 服务寻址：服务注册发现，Call ID 映射实现，RMI, 可以直接使用函数字符串，也可以使用整数 ID。映射表一般就是一个哈希表。
* 序列化反序列化：可以自己写，也可以使用 Protobuf 或者 FlatBuffers 之类的。
* 网络传输库：可以自己写 Socket，或者用 Asio，ZeroMQ，Netty 之类。

#### 2. 通信过程
1. 客户端（client）以本地调用方式（即以接口的方式）调用服务；
2. 客户端存根（client stub）接收到调用后，负责将方法、参数等组装成能够进行网络传输的消息体
（将消息体对象序列化为二进制）；
3. 客户端通过sockets将消息发送到服务端；
4. 服务端存根( server stub）收到消息后进行解码（将消息对象反序列化）；
5. 服务端存根( server stub）根据解码结果调用本地的服务；
6. 本地服务执行并将结果返回给服务端存根( server stub）；
7. 服务端存根( server stub）将返回结果打包成消息（将结果消息对象序列化）；
8. 服务端（server）通过sockets将消息发送到客户端；
9. 客户端存根（client stub）接收到结果消息，并进行解码（将结果消息发序列化）；
10. 客户端（client）得到最终结果

#### 3.RPC 和 HTTP 对比
1. RPC主要用于公司内部的服务调用，性能消耗低，传输效率高，服务质量方便。
2. http主要用于对外的异构环境，浏览器接口调用，app接口调用，第三方接口调用等
3. 传输协议
4. 传输效率
5. 性能消耗
6. 负载均衡：http需要配置nginx, Haproxy实现；rpc基本自带负载均衡
7. 服务治理：http需要实现通知，修改：nginx,Haproxy配置；rpc可以做到自动通知，不影响上游

### 分布式通信协议
* paxos: 二阶段提交，简单来说，二阶段提交就是，一个节点询问其他节点，我是不是可以进行消息提交。如果收到所有人的同意，则告诉大家，开始提交吧。

* Raft: 发现主节点失踪一段时间后，所有从节点向其它从节点发消息，让他们选自己为新的主节点；

* gossip: 流言协议，它常用于P2P的通信协议，这个协议就是模拟人类中传播谣言的行为而来。
               
### 单体架构和微服务对比

#### 单体架构

##### 缺点
* 代码维护难开发效率低
    由于所有的代码都写在一个项目里面，要想要修改某一个功能点那么需要对项目的整体逻辑
    和设计有较深的理解，否则代码耦合严重，导致维护难，特别对于新入职的员工来说这将是
    最容易出现问题的地方。 加之所有功能在一块，导致一个项目很大很笨重，开发难度增加
    
* 扩展性
  在高并发的情况下，我们往往不是整个项目的每一个功能都处于高流量高请求的情况下的，
  很多时候都是某一个功能模块使用的人数比较多，在单体结构下我们没有办法针对单个功能
  实现分布式扩展，必须整个项目一起部署
  
#### 微服务架构
##### 优点
* 拆分业务 把整体大项目分割成不同小项目运行在不同进程或者机器上实现数据隔离
* 技术栈 每个服务可以由不同的团队或者开发者进行开发，外部调用人员不需要操心具体怎么实现的，只需要类似调用自己方法一样或者接口一样按照服务提供者给出来的参数传递即可
* 独立部署，每一个服务独立部署，部署一个服务不会影响整体项目，如果部署失败最多是这个服务的功能缺失，并不影响其他功能的使用
* 按需部署，针对不同的需求可以给不同的服务自由扩展服务器，根据服务的规模部署满足需求的实例
* 局部修改，当一个服务有新需求或者其他修改，不需要修改整体项目只要管好自己的服务就好了  